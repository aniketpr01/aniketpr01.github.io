{"status":"ok","feed":{"url":"https://medium.com/feed/@@aniketpr01","title":"Stories by Aniket Prajapati  on Medium","link":"https://medium.com/@aniketpr01?source=rss-67a7911682c1------2","author":"","description":"Stories by Aniket Prajapati  on Medium","image":"https://cdn-images-1.medium.com/fit/c/150/150/1*mo3b0TgdKA2n5gPMcu1v-g.jpeg"},"items":[{"title":"As a developer, working with smart contract events on the blockchain can be challenging, as it\u2026","pubDate":"2023-01-10 13:04:06","link":"https://medium.com/coinmonks/as-a-developer-working-with-smart-contract-events-on-the-blockchain-can-be-challenging-as-it-9dfc8b80ee37?source=rss-67a7911682c1------2","guid":"https://medium.com/p/9dfc8b80ee37","author":"Aniket Prajapati","thumbnail":"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9dfc8b80ee37","description":"\n<h3>Streamlining Smart Contract Event Querying with Graph Protocols</h3>\n<p>As a developer, working with smart contract events on the blockchain can be challenging, as it requires manually parsing through large amounts of data to find the events of interest. One way to mitigate this issue is by using a graph protocol, which allows for more efficient and user-friendly querying of data on the blockchain.</p>\n<p>One popular example of a graph protocol is The Graph, which allows for indexing and querying smart contract events on the Ethereum blockchain. The Graph uses a GraphQL API, which allows developers to easily query data stored on the blockchain in a way similar to how one would interact with a traditional database.</p>\n<p>To demonstrate the use of a graph protocol, let\u2019s consider a simple example of a smart contract that tracks the transfer of a token. The smart contract is written in Solidity 0.8; the following code snippet shows the events that are emitted in the contract:</p>\n<pre>pragma solidity ^0.8.0;<br><br>contract Token {<br>    event Transfer(address indexed from, address indexed to, uint256 value);<br><br>    function transfer(address _to, uint256 _value) public {<br>        emit Transfer(msg.sender, _to, _value);<br>    }<br>}</pre>\n<p>In this example, the Transfer event is emitted when the transfer the function is executed, with the from, to, and value variables being passed as arguments. These events can be easily indexed and queried using a graph protocol like The Graph. For example, a developer could use the following GraphQL query to retrieve all Transfer events where the to the address is a specific Ethereum\u00a0address:</p>\n<pre>{<br>    transfers(where: {to: \"0x123456789abcdef\"}) {<br>        from<br>        to<br>        value<br>    }<br>}</pre>\n<p>This query will return all the Transfer events where the to the address is \"0x123456789abcdef\" and the from and value of the\u00a0events.</p>\n<p>As seen in this example, a graph protocol allows developers to easily query smart contract events and retrieve the specific data they need. This can save significant time and effort while making it easier to build decentralized applications that are more user-friendly and tailored to specific use\u00a0cases.</p>\n<blockquote>New to trading? Try <a href=\"https://medium.com/coinmonks/crypto-trading-bot-c2ffce8acb2a\">crypto trading bots</a> or <a href=\"https://medium.com/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c\">copy trading</a> on <a href=\"https://medium.com/coinmonks/crypto-exchange-dd2f9d6f3769\">best crypto exchanges</a>\n</blockquote>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9dfc8b80ee37\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://medium.com/coinmonks/as-a-developer-working-with-smart-contract-events-on-the-blockchain-can-be-challenging-as-it-9dfc8b80ee37\">As a developer, working with smart contract events on the blockchain can be challenging, as it\u2026</a> was originally published in <a href=\"https://medium.com/coinmonks\">Coinmonks</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n","content":"\n<h3>Streamlining Smart Contract Event Querying with Graph Protocols</h3>\n<p>As a developer, working with smart contract events on the blockchain can be challenging, as it requires manually parsing through large amounts of data to find the events of interest. One way to mitigate this issue is by using a graph protocol, which allows for more efficient and user-friendly querying of data on the blockchain.</p>\n<p>One popular example of a graph protocol is The Graph, which allows for indexing and querying smart contract events on the Ethereum blockchain. The Graph uses a GraphQL API, which allows developers to easily query data stored on the blockchain in a way similar to how one would interact with a traditional database.</p>\n<p>To demonstrate the use of a graph protocol, let\u2019s consider a simple example of a smart contract that tracks the transfer of a token. The smart contract is written in Solidity 0.8; the following code snippet shows the events that are emitted in the contract:</p>\n<pre>pragma solidity ^0.8.0;<br><br>contract Token {<br>    event Transfer(address indexed from, address indexed to, uint256 value);<br><br>    function transfer(address _to, uint256 _value) public {<br>        emit Transfer(msg.sender, _to, _value);<br>    }<br>}</pre>\n<p>In this example, the Transfer event is emitted when the transfer the function is executed, with the from, to, and value variables being passed as arguments. These events can be easily indexed and queried using a graph protocol like The Graph. For example, a developer could use the following GraphQL query to retrieve all Transfer events where the to the address is a specific Ethereum\u00a0address:</p>\n<pre>{<br>    transfers(where: {to: \"0x123456789abcdef\"}) {<br>        from<br>        to<br>        value<br>    }<br>}</pre>\n<p>This query will return all the Transfer events where the to the address is \"0x123456789abcdef\" and the from and value of the\u00a0events.</p>\n<p>As seen in this example, a graph protocol allows developers to easily query smart contract events and retrieve the specific data they need. This can save significant time and effort while making it easier to build decentralized applications that are more user-friendly and tailored to specific use\u00a0cases.</p>\n<blockquote>New to trading? Try <a href=\"https://medium.com/coinmonks/crypto-trading-bot-c2ffce8acb2a\">crypto trading bots</a> or <a href=\"https://medium.com/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c\">copy trading</a> on <a href=\"https://medium.com/coinmonks/crypto-exchange-dd2f9d6f3769\">best crypto exchanges</a>\n</blockquote>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9dfc8b80ee37\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://medium.com/coinmonks/as-a-developer-working-with-smart-contract-events-on-the-blockchain-can-be-challenging-as-it-9dfc8b80ee37\">As a developer, working with smart contract events on the blockchain can be challenging, as it\u2026</a> was originally published in <a href=\"https://medium.com/coinmonks\">Coinmonks</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n","enclosure":{},"categories":["smart-contract-blockchain","events","smartcontractdevelopment","blockchain","solidity"]},{"title":"The Benefits and Challenges of Implementing Upgradeable Smart Contracts","pubDate":"2023-01-03 05:22:56","link":"https://aniketpr01.medium.com/the-benefits-and-challenges-of-implementing-upgradeable-smart-contracts-7b48d7157018?source=rss-67a7911682c1------2","guid":"https://medium.com/p/7b48d7157018","author":"Aniket Prajapati","thumbnail":"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7b48d7157018","description":"\n<p>Upgradeable smart contracts are smart contracts that allow for their code and/or data to be modified after deployment. This can be useful for making improvements or fixes to a contract without the need to redeploy it and create a new contract on the blockchain.</p>\n<p>Proxy contracts are the most popular ways of creating upgradeable smart contracts. Basically, a proxy contract is using delegate call to achieve upgradeability.</p>\n<p>A delegate call means running the contract on some other logic but using our own\u00a0context.</p>\n<p>For example:</p>\n<p>A -&gt; calls -&gt;\u00a0B</p>\n<p>B -&gt; delegatecalls -&gt;\u00a0C</p>\n<p>Here, B is delegating call to C, which means, code will be executed in C\u2019s context, but state variables will be used from B\u2019s context, which is the whole concept of a proxy contract.</p>\n<p>This can be achieved by either manually writing proxy contracts or using libraries like openzeppelin.</p>\n<p>Using proxy contract, the smart contracts can be upgradeable by differentiating the code logic/execution in one contract and storing the state variables in another contract, which is the default contract that a user interacts. Therefore, a user unless checks the source code, will not be able to identify if the smart contract is\u00a0updated.</p>\n<p>There are some pros and cons using upgradeable smart contracts:</p>\n<p>Pros:</p>\n<ul>\n<li>The ability to make improvements or fixes to a contract without the need to redeploy it and create a new contract on the blockchain.</li>\n<li>The ability to roll back changes to a contract if necessary.</li>\n</ul>\n<p>Cons:</p>\n<ul>\n<li>The contract code\u2019s added complexity can make it more challenging to understand and\u00a0audit.</li>\n<li>The risk of causing confusion or disruption for contract users if the upgrade process is not handled smoothly.</li>\n<li>The possibility that the upgrade process could fail, leading to potential loss of funds or other\u00a0issues.</li>\n</ul>\n<p>Using upgradeable contracts also makes it vulnerable to security\u00a0threats:</p>\n<ul>\n<li>There is potential for unauthorized upgrades if the contract has proper access control mechanisms.</li>\n<li>The potential for the contract\u2019s upgrade mechanism to be exploited by attackers.</li>\n<li>The need to carefully consider and plan for the impact of upgrades on contract users and stakeholders.</li>\n<li>The need to thoroughly test and audit the contract to ensure it is secure and functions as intended.</li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=7b48d7157018\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>Upgradeable smart contracts are smart contracts that allow for their code and/or data to be modified after deployment. This can be useful for making improvements or fixes to a contract without the need to redeploy it and create a new contract on the blockchain.</p>\n<p>Proxy contracts are the most popular ways of creating upgradeable smart contracts. Basically, a proxy contract is using delegate call to achieve upgradeability.</p>\n<p>A delegate call means running the contract on some other logic but using our own\u00a0context.</p>\n<p>For example:</p>\n<p>A -&gt; calls -&gt;\u00a0B</p>\n<p>B -&gt; delegatecalls -&gt;\u00a0C</p>\n<p>Here, B is delegating call to C, which means, code will be executed in C\u2019s context, but state variables will be used from B\u2019s context, which is the whole concept of a proxy contract.</p>\n<p>This can be achieved by either manually writing proxy contracts or using libraries like openzeppelin.</p>\n<p>Using proxy contract, the smart contracts can be upgradeable by differentiating the code logic/execution in one contract and storing the state variables in another contract, which is the default contract that a user interacts. Therefore, a user unless checks the source code, will not be able to identify if the smart contract is\u00a0updated.</p>\n<p>There are some pros and cons using upgradeable smart contracts:</p>\n<p>Pros:</p>\n<ul>\n<li>The ability to make improvements or fixes to a contract without the need to redeploy it and create a new contract on the blockchain.</li>\n<li>The ability to roll back changes to a contract if necessary.</li>\n</ul>\n<p>Cons:</p>\n<ul>\n<li>The contract code\u2019s added complexity can make it more challenging to understand and\u00a0audit.</li>\n<li>The risk of causing confusion or disruption for contract users if the upgrade process is not handled smoothly.</li>\n<li>The possibility that the upgrade process could fail, leading to potential loss of funds or other\u00a0issues.</li>\n</ul>\n<p>Using upgradeable contracts also makes it vulnerable to security\u00a0threats:</p>\n<ul>\n<li>There is potential for unauthorized upgrades if the contract has proper access control mechanisms.</li>\n<li>The potential for the contract\u2019s upgrade mechanism to be exploited by attackers.</li>\n<li>The need to carefully consider and plan for the impact of upgrades on contract users and stakeholders.</li>\n<li>The need to thoroughly test and audit the contract to ensure it is secure and functions as intended.</li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=7b48d7157018\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["smart-contract-auditing","solidity","smart-contract-security","upgradeable","blockchain"]},{"title":"The dangers of using blockhash and block timestamp for randomness in Ethereum contracts","pubDate":"2023-01-01 18:02:52","link":"https://aniketpr01.medium.com/the-dangers-of-using-blockhash-and-block-timestamp-for-randomness-in-ethereum-contracts-88ebece2ad08?source=rss-67a7911682c1------2","guid":"https://medium.com/p/88ebece2ad08","author":"Aniket Prajapati","thumbnail":"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=88ebece2ad08","description":"\n<p>blockhash and block.timestamp are two properties of blocks in the Ethereum blockchain that contract developers often use to generate random numbers. However, there are several reasons why these methods should be avoided for this\u00a0purpose.</p>\n<p>First, the blockhash of a block is determined by the transactions and state roots of the previous block. This means that it is not truly random, as it is based on known information when the block is\u00a0mined.</p>\n<p>Similarly, the block timestamp is set by the block's miner and is not guaranteed to be accurate. Miners can manipulate the timestamp to their advantage, leading to potential security vulnerabilities.</p>\n<p>Additionally, both blockhash and block timestamp are deterministic, which means that they will always produce the same output given the same input. This makes it easy for attackers to predict the output of these functions and exploit any vulnerabilities that may exist in your contract.</p>\n<p>Here is an\u00a0example:</p>\n<pre>contract GuessRandomNo {<br>  contructor() payable {}<br><br>  function guessNo(uint _guess) public {<br>    uint anser = uint(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp)));<br>  }<br><br>  if (_guess == answer){<br>    (bool sent, ) = msg.sender.call{value: 1 ether}(\"\");<br>    require(sent, \"Failed to send ether\");<br>  }<br>}</pre>\n<p>The above vulnerability can easily be exploited:</p>\n<pre>contract Attack {<br>    receive() external payable {}<br><br>    function attact(GuessTheRandomNumber guessTheRandomNumber) public {<br>        uint answer = uint(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp)));<br>        guessRandomNo.guessNo(answer);<br>    }<br><br>    function getBalance() public view returns(uint) {<br>        return address(this).balance;<br>    }<br>}</pre>\n<p>Since both the transaction will be in the same block, the blocknumber and therefore blockhash will be same, and block.timestamp will also be the same, and therefore, attacker can easily find the random number and extract the ethers out of the contract.</p>\n<p>In summary, it is important to be cautious when using blockhash and block.timestamp for generating random numbers in your contracts. Instead, consider using Oracles like chainlink VRF.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=88ebece2ad08\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>blockhash and block.timestamp are two properties of blocks in the Ethereum blockchain that contract developers often use to generate random numbers. However, there are several reasons why these methods should be avoided for this\u00a0purpose.</p>\n<p>First, the blockhash of a block is determined by the transactions and state roots of the previous block. This means that it is not truly random, as it is based on known information when the block is\u00a0mined.</p>\n<p>Similarly, the block timestamp is set by the block's miner and is not guaranteed to be accurate. Miners can manipulate the timestamp to their advantage, leading to potential security vulnerabilities.</p>\n<p>Additionally, both blockhash and block timestamp are deterministic, which means that they will always produce the same output given the same input. This makes it easy for attackers to predict the output of these functions and exploit any vulnerabilities that may exist in your contract.</p>\n<p>Here is an\u00a0example:</p>\n<pre>contract GuessRandomNo {<br>  contructor() payable {}<br><br>  function guessNo(uint _guess) public {<br>    uint anser = uint(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp)));<br>  }<br><br>  if (_guess == answer){<br>    (bool sent, ) = msg.sender.call{value: 1 ether}(\"\");<br>    require(sent, \"Failed to send ether\");<br>  }<br>}</pre>\n<p>The above vulnerability can easily be exploited:</p>\n<pre>contract Attack {<br>    receive() external payable {}<br><br>    function attact(GuessTheRandomNumber guessTheRandomNumber) public {<br>        uint answer = uint(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp)));<br>        guessRandomNo.guessNo(answer);<br>    }<br><br>    function getBalance() public view returns(uint) {<br>        return address(this).balance;<br>    }<br>}</pre>\n<p>Since both the transaction will be in the same block, the blocknumber and therefore blockhash will be same, and block.timestamp will also be the same, and therefore, attacker can easily find the random number and extract the ethers out of the contract.</p>\n<p>In summary, it is important to be cautious when using blockhash and block.timestamp for generating random numbers in your contracts. Instead, consider using Oracles like chainlink VRF.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=88ebece2ad08\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["solidity","smart-contract-auditing","smart-contract-blockchain","smart-contract-security","hacking"]},{"title":"Delegate call: A double edge sword","pubDate":"2023-01-01 17:07:34","link":"https://aniketpr01.medium.com/delegate-call-a-double-edge-sword-d62f586935?source=rss-67a7911682c1------2","guid":"https://medium.com/p/d62f586935","author":"Aniket Prajapati","thumbnail":"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d62f586935","description":"\n<p>Delegate call is a valuable tool in the Ethereum ecosystem that allows contract developers to execute code from another contract as if it were part of the calling contract. This can be useful for various purposes, such as code reuse, upgradeability, and modularity.</p>\n<p>Note that when using delegate call, the storage and balance of the calling contract are used rather than those of the contract being called. Any changes to storage or balance made by the delegate contract will affect the calling contract.</p>\n<p>The objective is to change the owner for the Base contract.</p>\n<pre>contract Base {<br>  address public owner;<br>  Temp public temp;<br><br>  constructor(Temp _temp) public {<br>    owner = msg.sender;<br>    temp = Temp(_temp);<br>  }<br><br>  fallback() external payable {<br>    address(temp).delegatecall(msg.data);<br>  }<br>}<br><br>contract Temp {<br>  address public owner;<br><br>  function pwn() public {<br>    owner = msg.sender;<br>  }<br>}</pre>\n<p>In the above code, when we delegate call from Base to Temp, the code will be executed from the Temp contract, but variables, value, and eth will be used for the Base contract.</p>\n<blockquote>Note: <strong>Must remember things about delegate call: delegate call preserves context, and storage layout must be same for A and\u00a0B.</strong>\n</blockquote>\n<pre>contract Hack {<br>  address public Base;<br><br>  constructor(address _base) public {<br>    base = _base;<br>  }<br><br>  function hack() public {<br>    base.call(abi.encodeWithSignature(\"pwn()\"));<br>  }<br>}</pre>\n<p>The goal is to call the pwn function from the Temp contract, which can only be called by calling fallback function from the Base contract.</p>\n<p>Now, when we call the hack function, it will try to call the pwn() function inside the Base contract, which is not available; hence fallback function will be executed, which will delegate the call to the pwn() function for the Temp contract with the msg.data. The owner-state variable will then be updated for the Base contract and not for the Temp contract, as it is a delegate\u00a0call.</p>\n<p><strong><em>Conclusion:</em></strong></p>\n<p>Delegate call can be a powerful tool for contract developers, but it is important to use them carefully and consider the potential consequences of executing external\u00a0code.</p>\n<p>One potential use case for delegate call is code reuse. Instead of duplicating code across multiple contracts, you can use delegate call to share code between contracts. This can help to reduce code duplication and improve maintainability.</p>\n<p>Another use case is contract upgradeability. You can update a contract using delegate call without changing its address or breaking any existing references. This can make deploying updates and fixing bugs easier without disrupting your contract\u2019s users.</p>\n<p>Finally, delegate call can be used to improve the modularity of your contract architecture. By separating different functionality into separate contracts and using delegate call to invoke them, you can make your contracts more modular and easier to understand.</p>\n<p>Delegate call is a useful feature in Solidity that can help you write more efficient and maintainable contract\u00a0code.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=d62f586935\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>Delegate call is a valuable tool in the Ethereum ecosystem that allows contract developers to execute code from another contract as if it were part of the calling contract. This can be useful for various purposes, such as code reuse, upgradeability, and modularity.</p>\n<p>Note that when using delegate call, the storage and balance of the calling contract are used rather than those of the contract being called. Any changes to storage or balance made by the delegate contract will affect the calling contract.</p>\n<p>The objective is to change the owner for the Base contract.</p>\n<pre>contract Base {<br>  address public owner;<br>  Temp public temp;<br><br>  constructor(Temp _temp) public {<br>    owner = msg.sender;<br>    temp = Temp(_temp);<br>  }<br><br>  fallback() external payable {<br>    address(temp).delegatecall(msg.data);<br>  }<br>}<br><br>contract Temp {<br>  address public owner;<br><br>  function pwn() public {<br>    owner = msg.sender;<br>  }<br>}</pre>\n<p>In the above code, when we delegate call from Base to Temp, the code will be executed from the Temp contract, but variables, value, and eth will be used for the Base contract.</p>\n<blockquote>Note: <strong>Must remember things about delegate call: delegate call preserves context, and storage layout must be same for A and\u00a0B.</strong>\n</blockquote>\n<pre>contract Hack {<br>  address public Base;<br><br>  constructor(address _base) public {<br>    base = _base;<br>  }<br><br>  function hack() public {<br>    base.call(abi.encodeWithSignature(\"pwn()\"));<br>  }<br>}</pre>\n<p>The goal is to call the pwn function from the Temp contract, which can only be called by calling fallback function from the Base contract.</p>\n<p>Now, when we call the hack function, it will try to call the pwn() function inside the Base contract, which is not available; hence fallback function will be executed, which will delegate the call to the pwn() function for the Temp contract with the msg.data. The owner-state variable will then be updated for the Base contract and not for the Temp contract, as it is a delegate\u00a0call.</p>\n<p><strong><em>Conclusion:</em></strong></p>\n<p>Delegate call can be a powerful tool for contract developers, but it is important to use them carefully and consider the potential consequences of executing external\u00a0code.</p>\n<p>One potential use case for delegate call is code reuse. Instead of duplicating code across multiple contracts, you can use delegate call to share code between contracts. This can help to reduce code duplication and improve maintainability.</p>\n<p>Another use case is contract upgradeability. You can update a contract using delegate call without changing its address or breaking any existing references. This can make deploying updates and fixing bugs easier without disrupting your contract\u2019s users.</p>\n<p>Finally, delegate call can be used to improve the modularity of your contract architecture. By separating different functionality into separate contracts and using delegate call to invoke them, you can make your contracts more modular and easier to understand.</p>\n<p>Delegate call is a useful feature in Solidity that can help you write more efficient and maintainable contract\u00a0code.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=d62f586935\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["smart-contract-security","solidity","smart-contract-auditing"]},{"title":"Avoiding Arithmetic Vulnerabilities in Smart Contracts: Overflow and Underflow","pubDate":"2023-01-01 11:27:57","link":"https://aniketpr01.medium.com/avoiding-arithmetic-vulnerabilities-in-smart-contracts-overflow-and-underflow-13d8212acf5a?source=rss-67a7911682c1------2","guid":"https://medium.com/p/13d8212acf5a","author":"Aniket Prajapati","thumbnail":"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=13d8212acf5a","description":"\n<p>Arithmetic overflow and underflow are vulnerabilities in smart contracts, self-executing programs that run on a blockchain. These vulnerabilities can occur when a contract performs arithmetic operations on variables that exceed the maximum or minimum value that can be stored in that variable.</p>\n<p>Overflow occurs when the result of an arithmetic operation is greater than the maximum value that can be stored in the variable. This can cause the result to wrap around to the minimum value, leading to unexpected and potentially dangerous consequences.</p>\n<p>Underflow occurs when the result of an arithmetic operation is less than the minimum value that can be stored in the variable. This can also cause the result to wrap around to the maximum value, leading to unexpected consequences.</p>\n<p>Here is an example of code that is vulnerable to arithmetic overflow:</p>\n<pre>pragma solidity ^0.6.0;<br><br>contract Overflow {<br>    uint public balance;<br><br>    function deposit() public payable {<br>        balance += msg.value;<br>    }<br>}</pre>\n<p>In this example, the deposit() function allows users to send ether to the contract and adds the amount to the balance variable. However, if the balance variable exceeds the maximum value that can be stored in a uint (which is 2^256 - 1), an overflow will occur and the balance will wrap around to a lower\u00a0value.</p>\n<p>To prevent arithmetic overflow and underflow, smart contract developers must ensure that their contracts perform proper bounds checking on variables. This can be done by using the SafeMath library, which provides several functions for performing arithmetic operations safely and securely.</p>\n<p>Here is an example of how to use the SafeMath library to prevent arithmetic overflow:</p>\n<pre>pragma solidity ^0.6.0;<br><br>import \"https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol\";<br><br>contract Overflow {<br>    using SafeMath for uint;<br><br>    uint public balance;<br><br>    function deposit() public payable {<br>        balance = balance.add(msg.value);<br>    }<br>}</pre>\n<p>In this example, the deposit() function uses the add() function from the SafeMath library to add the amount of ether sent to the contract to the balance variable. If an overflow had occurred, the add() the function will instead throw an exception, and the transaction will be reverted.</p>\n<p>Note: solidity version 0.8 has already fixed this issue, and there is no explicit need to use the SafeMath library, onwards from 0.8\u00a0version.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=13d8212acf5a\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>Arithmetic overflow and underflow are vulnerabilities in smart contracts, self-executing programs that run on a blockchain. These vulnerabilities can occur when a contract performs arithmetic operations on variables that exceed the maximum or minimum value that can be stored in that variable.</p>\n<p>Overflow occurs when the result of an arithmetic operation is greater than the maximum value that can be stored in the variable. This can cause the result to wrap around to the minimum value, leading to unexpected and potentially dangerous consequences.</p>\n<p>Underflow occurs when the result of an arithmetic operation is less than the minimum value that can be stored in the variable. This can also cause the result to wrap around to the maximum value, leading to unexpected consequences.</p>\n<p>Here is an example of code that is vulnerable to arithmetic overflow:</p>\n<pre>pragma solidity ^0.6.0;<br><br>contract Overflow {<br>    uint public balance;<br><br>    function deposit() public payable {<br>        balance += msg.value;<br>    }<br>}</pre>\n<p>In this example, the deposit() function allows users to send ether to the contract and adds the amount to the balance variable. However, if the balance variable exceeds the maximum value that can be stored in a uint (which is 2^256 - 1), an overflow will occur and the balance will wrap around to a lower\u00a0value.</p>\n<p>To prevent arithmetic overflow and underflow, smart contract developers must ensure that their contracts perform proper bounds checking on variables. This can be done by using the SafeMath library, which provides several functions for performing arithmetic operations safely and securely.</p>\n<p>Here is an example of how to use the SafeMath library to prevent arithmetic overflow:</p>\n<pre>pragma solidity ^0.6.0;<br><br>import \"https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol\";<br><br>contract Overflow {<br>    using SafeMath for uint;<br><br>    uint public balance;<br><br>    function deposit() public payable {<br>        balance = balance.add(msg.value);<br>    }<br>}</pre>\n<p>In this example, the deposit() function uses the add() function from the SafeMath library to add the amount of ether sent to the contract to the balance variable. If an overflow had occurred, the add() the function will instead throw an exception, and the transaction will be reverted.</p>\n<p>Note: solidity version 0.8 has already fixed this issue, and there is no explicit need to use the SafeMath library, onwards from 0.8\u00a0version.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=13d8212acf5a\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["blockchain","smart-contract-auditing","smartcontractdevelopment","smart-contract-security","solidity"]},{"title":"Exploiting Smart Contracts: The Dangers of Reentrancy Attacks","pubDate":"2023-01-01 11:18:11","link":"https://medium.com/coinmonks/exploiting-smart-contracts-the-dangers-of-reentrancy-attacks-df071f4ba6d6?source=rss-67a7911682c1------2","guid":"https://medium.com/p/df071f4ba6d6","author":"Aniket Prajapati","thumbnail":"https://cdn-images-1.medium.com/max/540/1*7E1eR_R8TsVbuPK185l8Cg.png","description":"\n<p>Reentrancy attacks are a type of vulnerability that can occur in smart contracts, which are self-executing programs that run on a blockchain. A smart contract is designed to perform certain actions when certain conditions are met, but if the contract is not programmed correctly, it can be exploited by an attacker.</p>\n<p>One example of a reentrancy attack is the \u201cDAO hack\u201d that occurred in 2016. The Decentralized Autonomous Organization (DAO) was a smart contract on the Ethereum blockchain designed to act as a decentralized venture capital fund. It allowed users to propose projects and vote on whether to fund\u00a0them.</p>\n<blockquote>New to trading? Try <a href=\"https://medium.com/coinmonks/crypto-trading-bot-c2ffce8acb2a\">crypto trading bots</a> or <a href=\"https://medium.com/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c\">copy trading</a> on <a href=\"https://medium.com/coinmonks/crypto-exchange-dd2f9d6f3769\">best crypto exchanges</a>\n</blockquote>\n<p>The DAO contract contained a vulnerability that allowed an attacker to repeatedly call a function that transferred ether (the native cryptocurrency of the Ethereum blockchain) from the DAO to the attacker\u2019s account. This function contained a call to another function that updated the internal balance of the contract. Still, it did not properly check if the contract was in the process of executing another call before continuing. As a result, the attacker could call this function, draining the DAO of ether repeatedly.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/540/1*7E1eR_R8TsVbuPK185l8Cg.png\"></figure><pre>contract etherStore {<br>  function withdraw(uint _amount) public {<br>    require(balances[msg.sender] &gt;= _amount);<br>    (bool sent, ) = msg.sender.call{value: _amount}(\"\");<br>    require(sent, \"Failed to send Ether\");<br>    balances[msg.sender] -= _amount;<br>  }<br>} </pre>\n<p>In this example, withdraw function can be called by another contract in a recursive pattern, and all the funds can be withdrawn from the contract, as displayed below:</p>\n<pre>receive() external payable {<br>  if (address(etherStore).balance &gt;= 1 ether) {<br>    etherStore.withdraw(1 ether)<br>  }<br>}<br><br>function attack() external payable {<br>  require(msg.value &gt;= 1 ether);<br>  etherStore.deposit{value: 1 ether}();<br>  etherStore.withdraw(1 ether);<br>}</pre>\n<p>when the attack function is called, it will first call the deposit function; thereafter, it will call the withdraw function, as this contract has logic inside the receive function, which will trigger when withdraw function is called. receive function will again trigger the withdraw function and again receive funds, which will again call the receive function, and the process will repeat itself until all the funds from the contracts vanish.</p>\n<p>This can be solved by writing the call function after updating the balance\u00a0mapping.</p>\n<pre>contract etherStore {<br>  function withdraw(uint _amount) public {<br>    require(balances[msg.sender] &gt;= _amount);<br>    balances[msg.sender] -= _amount;<br>    (bool sent, ) = msg.sender.call{value: _amount}(\"\");<br>    require(sent, \"Failed to send Ether\");<br>  }<br>}</pre>\n<p>This can also be solved by using guard conditions as\u00a0below:</p>\n<pre>bool locked;<br>contract etherStore {<br>  function withdraw(uint _amount) public {<br>    require(!locked, \"contract is locked\");<br>    require(balances[msg.sender] &gt;= _amount);<br>    balances[msg.sender] -= _amount;<br>    (bool sent, ) = msg.sender.call{value: _amount}(\"\");<br>    require(sent, \"Failed to send Ether\");<br>    locked = true;<br>  }<br>}</pre>\n<p>It\u2019s important to note that while smart contracts have the potential to revolutionize various industries, they also bring with them new risks and vulnerabilities that must be carefully considered and addressed. As the use of smart contracts continues to grow, it\u2019s crucial that developers take steps to ensure the security and integrity of these programs.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=df071f4ba6d6\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://medium.com/coinmonks/exploiting-smart-contracts-the-dangers-of-reentrancy-attacks-df071f4ba6d6\">Exploiting Smart Contracts: The Dangers of Reentrancy Attacks</a> was originally published in <a href=\"https://medium.com/coinmonks\">Coinmonks</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n","content":"\n<p>Reentrancy attacks are a type of vulnerability that can occur in smart contracts, which are self-executing programs that run on a blockchain. A smart contract is designed to perform certain actions when certain conditions are met, but if the contract is not programmed correctly, it can be exploited by an attacker.</p>\n<p>One example of a reentrancy attack is the \u201cDAO hack\u201d that occurred in 2016. The Decentralized Autonomous Organization (DAO) was a smart contract on the Ethereum blockchain designed to act as a decentralized venture capital fund. It allowed users to propose projects and vote on whether to fund\u00a0them.</p>\n<blockquote>New to trading? Try <a href=\"https://medium.com/coinmonks/crypto-trading-bot-c2ffce8acb2a\">crypto trading bots</a> or <a href=\"https://medium.com/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c\">copy trading</a> on <a href=\"https://medium.com/coinmonks/crypto-exchange-dd2f9d6f3769\">best crypto exchanges</a>\n</blockquote>\n<p>The DAO contract contained a vulnerability that allowed an attacker to repeatedly call a function that transferred ether (the native cryptocurrency of the Ethereum blockchain) from the DAO to the attacker\u2019s account. This function contained a call to another function that updated the internal balance of the contract. Still, it did not properly check if the contract was in the process of executing another call before continuing. As a result, the attacker could call this function, draining the DAO of ether repeatedly.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/540/1*7E1eR_R8TsVbuPK185l8Cg.png\"></figure><pre>contract etherStore {<br>  function withdraw(uint _amount) public {<br>    require(balances[msg.sender] &gt;= _amount);<br>    (bool sent, ) = msg.sender.call{value: _amount}(\"\");<br>    require(sent, \"Failed to send Ether\");<br>    balances[msg.sender] -= _amount;<br>  }<br>} </pre>\n<p>In this example, withdraw function can be called by another contract in a recursive pattern, and all the funds can be withdrawn from the contract, as displayed below:</p>\n<pre>receive() external payable {<br>  if (address(etherStore).balance &gt;= 1 ether) {<br>    etherStore.withdraw(1 ether)<br>  }<br>}<br><br>function attack() external payable {<br>  require(msg.value &gt;= 1 ether);<br>  etherStore.deposit{value: 1 ether}();<br>  etherStore.withdraw(1 ether);<br>}</pre>\n<p>when the attack function is called, it will first call the deposit function; thereafter, it will call the withdraw function, as this contract has logic inside the receive function, which will trigger when withdraw function is called. receive function will again trigger the withdraw function and again receive funds, which will again call the receive function, and the process will repeat itself until all the funds from the contracts vanish.</p>\n<p>This can be solved by writing the call function after updating the balance\u00a0mapping.</p>\n<pre>contract etherStore {<br>  function withdraw(uint _amount) public {<br>    require(balances[msg.sender] &gt;= _amount);<br>    balances[msg.sender] -= _amount;<br>    (bool sent, ) = msg.sender.call{value: _amount}(\"\");<br>    require(sent, \"Failed to send Ether\");<br>  }<br>}</pre>\n<p>This can also be solved by using guard conditions as\u00a0below:</p>\n<pre>bool locked;<br>contract etherStore {<br>  function withdraw(uint _amount) public {<br>    require(!locked, \"contract is locked\");<br>    require(balances[msg.sender] &gt;= _amount);<br>    balances[msg.sender] -= _amount;<br>    (bool sent, ) = msg.sender.call{value: _amount}(\"\");<br>    require(sent, \"Failed to send Ether\");<br>    locked = true;<br>  }<br>}</pre>\n<p>It\u2019s important to note that while smart contracts have the potential to revolutionize various industries, they also bring with them new risks and vulnerabilities that must be carefully considered and addressed. As the use of smart contracts continues to grow, it\u2019s crucial that developers take steps to ensure the security and integrity of these programs.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=df071f4ba6d6\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://medium.com/coinmonks/exploiting-smart-contracts-the-dangers-of-reentrancy-attacks-df071f4ba6d6\">Exploiting Smart Contracts: The Dangers of Reentrancy Attacks</a> was originally published in <a href=\"https://medium.com/coinmonks\">Coinmonks</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n","enclosure":{},"categories":["reentrancy","solidity","reentrancy-attack","smart-contract-auditing","smart-contract-security"]},{"title":"Echidna: The Essential Tool for Ensuring the Security of Your Ethereum Smart Contracts","pubDate":"2023-01-01 03:30:52","link":"https://aniketpr01.medium.com/echidna-the-essential-tool-for-ensuring-the-security-of-your-ethereum-smart-contracts-4fe5d790f141?source=rss-67a7911682c1------2","guid":"https://medium.com/p/4fe5d790f141","author":"Aniket Prajapati","thumbnail":"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4fe5d790f141","description":"\n<p>Echidna is an open-source tool that allows developers to test their Ethereum smart contracts' security easily. It is an essential tool for any Ethereum developer. It can help identify potential vulnerabilities and attack vectors in smart contracts before they are deployed to the main Ethereum\u00a0network.</p>\n<p>One of the great things about Echidna is that it is easy to set up and use. This blog post will show you how to use Echidna with Docker, which can be a convenient way to run Echidna on your development machine.</p>\n<p>First, you will need to install Docker if you don\u2019t already have it. Once you have Docker installed, you can pull the Echidna Docker image using the following command:</p>\n<pre>docker pull nccgroup/echidna</pre>\n<p>Next, you will need to write your contract. For the purpose of this example, let\u2019s use a simple contract that adds two numbers together:</p>\n<pre>pragma solidity ^0.8.7;<br><br>contract Adder {<br>    function add(uint x, uint y) public view returns (uint) {<br>        return x + y;<br>    }<br>}</pre>\n<p>Now, you can test your contract using Echidna. To do this, you will need to create a JSON file that specifies the conditions under which your contract should be tested. Here is an example of what this file might look\u00a0like:</p>\n<pre>{<br>  \"contract\": \"Adder\",<br>  \"args\": [<br>    5,<br>    7<br>  ],<br>  \"tests\": [<br>    {<br>      \"name\": \"Addition test\",<br>      \"call\": \"add(uint,uint)\",<br>      \"result\": \"12\"<br>    }<br>  ]<br>}</pre>\n<p>This JSON file specifies that we want to test the add() function of our Adder contract with the arguments 5 and 7. We expect the result to be\u00a012.</p>\n<p>To run the test using Docker, we can use the following command:</p>\n<pre>docker run -v /path/to/test.json:/test.json nccgroup/echidna echidna-test /test.jsonEchidna will then run the test and let you know if it was successful. If the test passes, you will see a message like this:</pre>\n<p>This command will run Echidna in a Docker container and pass it the test.json File as an argument. Echidna will then run the test and let you know if it was successful. If the test passes, you will see a message like\u00a0this:</p>\n<pre>Test passed: Addition test</pre>\n<p>You will see a message indicating what went wrong if the test\u00a0fails.</p>\n<p>Using Echidna with Docker is a convenient way to run Echidna on your development machine, making it easy. Its automatic testing capabilities and customizability make it a valuable resource for any developer looking to build and deploy secure smart contracts.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=4fe5d790f141\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>Echidna is an open-source tool that allows developers to test their Ethereum smart contracts' security easily. It is an essential tool for any Ethereum developer. It can help identify potential vulnerabilities and attack vectors in smart contracts before they are deployed to the main Ethereum\u00a0network.</p>\n<p>One of the great things about Echidna is that it is easy to set up and use. This blog post will show you how to use Echidna with Docker, which can be a convenient way to run Echidna on your development machine.</p>\n<p>First, you will need to install Docker if you don\u2019t already have it. Once you have Docker installed, you can pull the Echidna Docker image using the following command:</p>\n<pre>docker pull nccgroup/echidna</pre>\n<p>Next, you will need to write your contract. For the purpose of this example, let\u2019s use a simple contract that adds two numbers together:</p>\n<pre>pragma solidity ^0.8.7;<br><br>contract Adder {<br>    function add(uint x, uint y) public view returns (uint) {<br>        return x + y;<br>    }<br>}</pre>\n<p>Now, you can test your contract using Echidna. To do this, you will need to create a JSON file that specifies the conditions under which your contract should be tested. Here is an example of what this file might look\u00a0like:</p>\n<pre>{<br>  \"contract\": \"Adder\",<br>  \"args\": [<br>    5,<br>    7<br>  ],<br>  \"tests\": [<br>    {<br>      \"name\": \"Addition test\",<br>      \"call\": \"add(uint,uint)\",<br>      \"result\": \"12\"<br>    }<br>  ]<br>}</pre>\n<p>This JSON file specifies that we want to test the add() function of our Adder contract with the arguments 5 and 7. We expect the result to be\u00a012.</p>\n<p>To run the test using Docker, we can use the following command:</p>\n<pre>docker run -v /path/to/test.json:/test.json nccgroup/echidna echidna-test /test.jsonEchidna will then run the test and let you know if it was successful. If the test passes, you will see a message like this:</pre>\n<p>This command will run Echidna in a Docker container and pass it the test.json File as an argument. Echidna will then run the test and let you know if it was successful. If the test passes, you will see a message like\u00a0this:</p>\n<pre>Test passed: Addition test</pre>\n<p>You will see a message indicating what went wrong if the test\u00a0fails.</p>\n<p>Using Echidna with Docker is a convenient way to run Echidna on your development machine, making it easy. Its automatic testing capabilities and customizability make it a valuable resource for any developer looking to build and deploy secure smart contracts.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=4fe5d790f141\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["smart-contract-blockchain","smart-contract-security","echidna","smart-contract-auditing","docker"]},{"title":"Tenderly\u200a\u2014\u200aThe Ultimate tool for smart contract monitoring on Ethereum","pubDate":"2023-01-01 02:51:09","link":"https://aniketpr01.medium.com/tenderly-the-ultimate-tool-for-smart-contract-monitoring-on-ethereum-8b674fee68c4?source=rss-67a7911682c1------2","guid":"https://medium.com/p/8b674fee68c4","author":"Aniket Prajapati","thumbnail":"https://cdn-images-1.medium.com/max/719/1*69ZFLngsUN7qY121peaQqg.png","description":"\n<h3>Tenderly\u200a\u2014\u200aThe Ultimate tool for smart contract development on\u00a0Ethereum</h3>\n<p>Tenderly is a suite of tools that helps developers build, debug, and monitor smart contracts on the Ethereum blockchain. It is designed to make it easier for developers to work with smart contracts and ensure that they are well-written and performant.</p>\n<p>Some of the key features of Tenderly\u00a0include:</p>\n<ul>\n<li>Debugger: Tenderly\u2019s debugger allows developers to step through the execution of their smart contracts and inspect the state of variables at each step. This can be helpful for identifying and fixing bugs in smart contracts.</li>\n<li>Tracer: Tenderly\u2019s tracer provides a visual representation of the flow of data and execution through a smart contract. This can be useful for understanding how a smart contract works and for debugging issues.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/719/1*69ZFLngsUN7qY121peaQqg.png\"></figure><ul>\n<li>Monitor: Tenderly\u2019s monitor tracks the performance and health of smart contracts and alerts developers if there are any issues. It can help developers identify and fix problems before they become\u00a0serious.</li>\n<li>Testing framework: Tenderly includes a testing framework that helps developers write and run unit tests for their smart contracts. This can be useful for ensuring that a smart contract works as intended and catching bugs before they are deployed to the main Ethereum\u00a0network.</li>\n</ul>\n<p>In addition to these core features, Tenderly also provides a number of other tools and resources for Ethereum developers, including a documentation library and integrations with popular development environments such as Visual Studio\u00a0Code.</p>\n<p>Overall, Tenderly is a well-regarded tool that is widely used by Ethereum developers for building, debugging, and maintaining smart contracts. It is a paid service, but many developers find that its features and tools are worth the\u00a0cost.</p>\n<p>Pros and\u00a0Cons:</p>\n<p>Pros:</p>\n<ul>\n<li>Tenderly provides a number of useful features that can help developers build and maintain their smart contracts more easily, such as the debugger, tracer, and testing framework.</li>\n<li>Tenderly\u2019s monitoring tools can help developers identify and fix issues with their smart contracts before they become serious problems.</li>\n<li>Tenderly is a well-established tool with a strong reputation in the Ethereum development community.</li>\n</ul>\n<p>Cons:</p>\n<ul>\n<li>Tenderly is a paid service, so there may be some cost involved in using\u00a0it.</li>\n<li>Tenderly is focused on Ethereum, so it may not be as useful for developers working with other blockchain platforms.</li>\n<li>Some developers may prefer to use other tools or build their own solutions for smart contract development and debugging.</li>\n</ul>\n<p>Some alternative tools to Tenderly that you might consider\u00a0include:</p>\n<ul>\n<li>Remix: Remix is a browser-based IDE for Ethereum development that includes a built-in debugger and testing tools. It is free and open-source.</li>\n<li>Truffle/Hardhat: This is a popular development framework for Ethereum that includes testing, debugging, and deployment tools. It is free and open-source.</li>\n<li>Ganache: Ganache is a local blockchain emulator that allows developers to test their smart contracts in a simulated environment. It is free and open-source.</li>\n<li>Mythril: Mythril is a security analysis tool for Ethereum smart contracts that helps developers find vulnerabilities and security issues. It is free and open-source.</li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=8b674fee68c4\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3>Tenderly\u200a\u2014\u200aThe Ultimate tool for smart contract development on\u00a0Ethereum</h3>\n<p>Tenderly is a suite of tools that helps developers build, debug, and monitor smart contracts on the Ethereum blockchain. It is designed to make it easier for developers to work with smart contracts and ensure that they are well-written and performant.</p>\n<p>Some of the key features of Tenderly\u00a0include:</p>\n<ul>\n<li>Debugger: Tenderly\u2019s debugger allows developers to step through the execution of their smart contracts and inspect the state of variables at each step. This can be helpful for identifying and fixing bugs in smart contracts.</li>\n<li>Tracer: Tenderly\u2019s tracer provides a visual representation of the flow of data and execution through a smart contract. This can be useful for understanding how a smart contract works and for debugging issues.</li>\n</ul>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/719/1*69ZFLngsUN7qY121peaQqg.png\"></figure><ul>\n<li>Monitor: Tenderly\u2019s monitor tracks the performance and health of smart contracts and alerts developers if there are any issues. It can help developers identify and fix problems before they become\u00a0serious.</li>\n<li>Testing framework: Tenderly includes a testing framework that helps developers write and run unit tests for their smart contracts. This can be useful for ensuring that a smart contract works as intended and catching bugs before they are deployed to the main Ethereum\u00a0network.</li>\n</ul>\n<p>In addition to these core features, Tenderly also provides a number of other tools and resources for Ethereum developers, including a documentation library and integrations with popular development environments such as Visual Studio\u00a0Code.</p>\n<p>Overall, Tenderly is a well-regarded tool that is widely used by Ethereum developers for building, debugging, and maintaining smart contracts. It is a paid service, but many developers find that its features and tools are worth the\u00a0cost.</p>\n<p>Pros and\u00a0Cons:</p>\n<p>Pros:</p>\n<ul>\n<li>Tenderly provides a number of useful features that can help developers build and maintain their smart contracts more easily, such as the debugger, tracer, and testing framework.</li>\n<li>Tenderly\u2019s monitoring tools can help developers identify and fix issues with their smart contracts before they become serious problems.</li>\n<li>Tenderly is a well-established tool with a strong reputation in the Ethereum development community.</li>\n</ul>\n<p>Cons:</p>\n<ul>\n<li>Tenderly is a paid service, so there may be some cost involved in using\u00a0it.</li>\n<li>Tenderly is focused on Ethereum, so it may not be as useful for developers working with other blockchain platforms.</li>\n<li>Some developers may prefer to use other tools or build their own solutions for smart contract development and debugging.</li>\n</ul>\n<p>Some alternative tools to Tenderly that you might consider\u00a0include:</p>\n<ul>\n<li>Remix: Remix is a browser-based IDE for Ethereum development that includes a built-in debugger and testing tools. It is free and open-source.</li>\n<li>Truffle/Hardhat: This is a popular development framework for Ethereum that includes testing, debugging, and deployment tools. It is free and open-source.</li>\n<li>Ganache: Ganache is a local blockchain emulator that allows developers to test their smart contracts in a simulated environment. It is free and open-source.</li>\n<li>Mythril: Mythril is a security analysis tool for Ethereum smart contracts that helps developers find vulnerabilities and security issues. It is free and open-source.</li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=8b674fee68c4\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["blockchain","debugging","smart-contract-auditing","smartcontractdevelopment","solidity"]},{"title":"Vegan vs. Vegetarian vs. Carnivorous diet","pubDate":"2022-11-11 02:31:52","link":"https://aniketpr01.medium.com/vegan-vs-vegetarian-vs-carnivorous-diet-4e722669cc39?source=rss-67a7911682c1------2","guid":"https://medium.com/p/4e722669cc39","author":"Aniket Prajapati","thumbnail":"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4e722669cc39","description":"\n<p>A human is a social animal by nature that has evolved over millions of years by natural selection. Human\u2019s now top the food chain because of the evolved brain and intelligence with which humans can literally make any living or nonliving extinct thing on the planet. Such is the power of human beings over\u00a0nature.</p>\n<p>Nutrition:<br>Meat-eaters believe they get all the nutrition from their diet, which is true, as a vegan diet cannot provide some primary nutrients like Vitamin B12 and Omega 3. Vegans and Vegetarians need to take these nutrients via supplements which can be unnatural but\u00a0safe.</p>\n<p>Cruelty:<br>Cruelty is the most apparent reason someone not eating meat or even dairy if they are vegan. Although I believe vegetarians consuming dairy is more in line with meat-eaters as dairy is cruel at multiple levels to all\u00a0animals.</p>\n<p>Environment:<br>Climate change is the ultimate killer of modern society, and carnivorous food has a large carbon footprint compared to vegan food. This is because the animals take up more space, water, and food to be fed before being consumed by\u00a0people.</p>\n<p>Emotions:<br>Emotions are the least important part of choosing a vegan, vegetarian, or meat eater. This is because we are social animals and have evolved over the years by eating a meat-based diet only. In evolution, it is said that \u201csurvival of the fittest.\u201d Hence ethically, it is in human nature to consume meat for survival, but modern society is right now surviving global warming, and the right thing to do is think in terms of the environment and stop eating meat because it is harmful to it and vegan food can fulfill almost all the nutrition requirements with few supplements.</p>\n<p>Modern carnivorous food is mainly processed and has been linked to multiple diseases compared to vegetarian or vegan food. Vegan food has been the choice of many sports athletes, entrepreneurs, celebrities, and influencers which clearly states that vegan food is better for health in the long run. A study done in Okinawa, Japan, which is the place where the most number of people are alive today over 100 years, and traditional Okinawa food is essentially a vegan food with occasional consumption of\u00a0meat.</p>\n<p>Meat consumption and Dairy consumption must only be for survival. We must strive towards saving the environment because if we don\u2019t, nature will eat everything, including humans.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=4e722669cc39\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>A human is a social animal by nature that has evolved over millions of years by natural selection. Human\u2019s now top the food chain because of the evolved brain and intelligence with which humans can literally make any living or nonliving extinct thing on the planet. Such is the power of human beings over\u00a0nature.</p>\n<p>Nutrition:<br>Meat-eaters believe they get all the nutrition from their diet, which is true, as a vegan diet cannot provide some primary nutrients like Vitamin B12 and Omega 3. Vegans and Vegetarians need to take these nutrients via supplements which can be unnatural but\u00a0safe.</p>\n<p>Cruelty:<br>Cruelty is the most apparent reason someone not eating meat or even dairy if they are vegan. Although I believe vegetarians consuming dairy is more in line with meat-eaters as dairy is cruel at multiple levels to all\u00a0animals.</p>\n<p>Environment:<br>Climate change is the ultimate killer of modern society, and carnivorous food has a large carbon footprint compared to vegan food. This is because the animals take up more space, water, and food to be fed before being consumed by\u00a0people.</p>\n<p>Emotions:<br>Emotions are the least important part of choosing a vegan, vegetarian, or meat eater. This is because we are social animals and have evolved over the years by eating a meat-based diet only. In evolution, it is said that \u201csurvival of the fittest.\u201d Hence ethically, it is in human nature to consume meat for survival, but modern society is right now surviving global warming, and the right thing to do is think in terms of the environment and stop eating meat because it is harmful to it and vegan food can fulfill almost all the nutrition requirements with few supplements.</p>\n<p>Modern carnivorous food is mainly processed and has been linked to multiple diseases compared to vegetarian or vegan food. Vegan food has been the choice of many sports athletes, entrepreneurs, celebrities, and influencers which clearly states that vegan food is better for health in the long run. A study done in Okinawa, Japan, which is the place where the most number of people are alive today over 100 years, and traditional Okinawa food is essentially a vegan food with occasional consumption of\u00a0meat.</p>\n<p>Meat consumption and Dairy consumption must only be for survival. We must strive towards saving the environment because if we don\u2019t, nature will eat everything, including humans.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=4e722669cc39\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["health","vegetarian","long-life","vegan","meat"]},{"title":"How a rigid perception fundamentally affects the economy","pubDate":"2022-11-02 19:02:09","link":"https://aniketpr01.medium.com/how-a-rigid-perception-fundamentally-affects-the-economy-7172ea60112b?source=rss-67a7911682c1------2","guid":"https://medium.com/p/7172ea60112b","author":"Aniket Prajapati","thumbnail":"https://cdn-images-1.medium.com/max/825/1*dqSDaz8FpEtlMXWg55w0Lg.png","description":"\n<p>India in itself is a vast spread of multiple beliefs and values. Many of us have grown up in families where our Parents and grandparents have seen some tough financial times and witnessed the super-wealthy inheritance as\u00a0well.</p>\n<p>I found it astounding how fast the world is moving, with capitalism at its core. The evolution of human civilization is at its peak; there is a need for constant upskilling, and it\u2019s more essential than ever for staying up to date with the world\u2019s growth. However, we still see an utterly contrasting mindset of people around us when dealing with spending and earning money. We have heard an old saying that goes like this \u201cJitni chaddar ho utna hi pair failana chahiye\u201d(Hindi), which means \u2018spread your legs only as much as the area of the blanket.\u2019</p>\n<p>If we have to progress, we should be doing it by earning more rather than saving more, as believed for thousands of years. This advice was partially correct because, in earlier times, saving money was a good option as there was little inflation. However, with current inflation, it will be terrible advice to save all the money in a bank or put it into a fixed deposit. In fact, if saving money becomes prominent across the nation, GDP will shrink, and the ripple effect will cripple the economy\u00a0further.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/825/1*dqSDaz8FpEtlMXWg55w0Lg.png\"></figure><p>Since the middle class has not been able to keep up with the fast-paced evolution the world is witnessing, they are getting pulled down to a less wealthy status, and this may get even worse if the fundamental thought pattern of the society is not\u00a0changed.</p>\n<p>I recently witnessed people spending hours of their personal and professional time saving a few tens-hundreds bucks or a 5%-10% discount, which is crazy as that personal or professional time wasted could have been far better utilized in learning something new and earning considerable wealth.</p>\n<p>What do you\u00a0think?</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=7172ea60112b\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>India in itself is a vast spread of multiple beliefs and values. Many of us have grown up in families where our Parents and grandparents have seen some tough financial times and witnessed the super-wealthy inheritance as\u00a0well.</p>\n<p>I found it astounding how fast the world is moving, with capitalism at its core. The evolution of human civilization is at its peak; there is a need for constant upskilling, and it\u2019s more essential than ever for staying up to date with the world\u2019s growth. However, we still see an utterly contrasting mindset of people around us when dealing with spending and earning money. We have heard an old saying that goes like this \u201cJitni chaddar ho utna hi pair failana chahiye\u201d(Hindi), which means \u2018spread your legs only as much as the area of the blanket.\u2019</p>\n<p>If we have to progress, we should be doing it by earning more rather than saving more, as believed for thousands of years. This advice was partially correct because, in earlier times, saving money was a good option as there was little inflation. However, with current inflation, it will be terrible advice to save all the money in a bank or put it into a fixed deposit. In fact, if saving money becomes prominent across the nation, GDP will shrink, and the ripple effect will cripple the economy\u00a0further.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/825/1*dqSDaz8FpEtlMXWg55w0Lg.png\"></figure><p>Since the middle class has not been able to keep up with the fast-paced evolution the world is witnessing, they are getting pulled down to a less wealthy status, and this may get even worse if the fundamental thought pattern of the society is not\u00a0changed.</p>\n<p>I recently witnessed people spending hours of their personal and professional time saving a few tens-hundreds bucks or a 5%-10% discount, which is crazy as that personal or professional time wasted could have been far better utilized in learning something new and earning considerable wealth.</p>\n<p>What do you\u00a0think?</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=7172ea60112b\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["growth","economy","hope","mindset"]}]}